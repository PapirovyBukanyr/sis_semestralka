#!/usr/bin/env python3
import os
import re

ROOT = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
TARGET_MD = os.path.join(ROOT, 'documentation.md')

def find_files():
    files = []
    for sub in ('receiver', 'sender'):
        dirp = os.path.join(ROOT, sub)
        for dirpath, dirnames, filenames in os.walk(dirp):
            for fn in filenames:
                if fn.endswith('.c') or fn.endswith('.h'):
                    files.append(os.path.join(dirpath, fn))
    return sorted(files)

re_start = re.compile(r"/\*\*")
re_end = re.compile(r"\*/")

def extract_docblocks_and_sigs(path):
    items = []
    with open(path, 'r', encoding='utf-8', errors='ignore') as f:
        s = f.read()
    idx = 0
    while True:
        m = re_start.search(s, idx)
        if not m: break
        start = m.start()
        me = re_end.search(s, m.end())
        if not me: break
        comment = s[m.start():me.end()]
        # find next non-empty, non-comment line after me.end()
        rest = s[me.end():]
        # skip whitespace and newlines
        lines = rest.splitlines()
        sig = None
        for ln in lines:
            ln_strip = ln.strip()
            if ln_strip == '':
                continue
            # skip leading single-line // comments
            if ln_strip.startswith('//'):
                continue
            # capture probable signature line (function or static int/void etc.)
            sig = ln_strip
            break
        items.append((comment.strip(), sig if sig else ''))
        idx = me.end()
    return items


def extract_function_names(path):
    """Find probable function definitions in a C source/header file.

    This uses a heuristic regex to capture identifiers followed by '(...)' and
    a following '{'. It skips common control keywords.
    """
    ctl = set(['if','for','while','switch','return','sizeof','else'])
    names = []
    with open(path, 'r', encoding='utf-8', errors='ignore') as f:
        s = f.read()
    # regex finds name( ... ){ with possible attributes before
    pattern = re.compile(r'\n\s*([A-Za-z_][A-Za-z0-9_]*)\s*\([^;{]*\)\s*\{', re.M)
    for m in pattern.finditer(s):
        name = m.group(1)
        if name in ctl:
            continue
        names.append(name)
    return sorted(set(names))


def normalize_comment(c):
    # Remove leading /** and trailing */ and leading * on lines
    lines = c.splitlines()
    if lines and lines[0].strip().startswith('/**'):
        lines = lines[1:]
    if lines and lines[-1].strip().endswith('*/'):
        lines = lines[:-1]
    cleaned = []
    for l in lines:
        # remove leading spaces and optional '*' char
        m = re.match(r"\s*\*?\s?(.*)$", l)
        if m:
            cleaned.append(m.group(1).rstrip())
        else:
            cleaned.append(l.rstrip())
    return '\n'.join(cleaned).strip()


def main():
    files = find_files()
    out = []
    out.append('# SIS Semestralka Documentation')
    out.append('\n Author: Marek PÅ™ibyl\n This document was autogenerated by tools/gen_docs.py.')

    # Group files by top-level folder (receiver/sender) and by module (immediate subdir)
    by_top = {'receiver':{}, 'sender':{}}
    for fp in files:
        rel = os.path.relpath(fp, ROOT).replace('\\','/')
        parts = rel.split('/')
        if parts[0] not in by_top:
            continue
        top = parts[0]
        # module is second part if present and starts with 'module' else use 'core'
        module = 'core'
        if len(parts) >= 3:
            # parts like receiver/module1/filename
            module = parts[1]
        else:
            module = 'core'
        by_top[top].setdefault(module, []).append((rel, fp))

    for top in ('receiver','sender'):
        out.append('\n# ' + top + '\n')
        modules = by_top.get(top, {})
        # ensure stable order: module names sorted, core last
        mod_names = sorted([m for m in modules.keys() if m != 'core'])
        if 'core' in modules:
            mod_names.append('core')
        for mod in mod_names:
            out.append('\n## ' + mod + '\n')
            for (rel, fp) in sorted(modules.get(mod, [])):
                out.append('\n### ' + rel + '\n')
                # Overview table: module and functions
                # extract functions via docblocks and regex
                items = extract_docblocks_and_sigs(fp)
                doc_funcs = []
                for (comment, sig) in items:
                    # try to extract function name from sig
                    name = ''
                    if sig:
                        mm = re.match(r'([A-Za-z_][A-Za-z0-9_\*\s]+)\s+([A-Za-z_][A-Za-z0-9_]*)\s*\(', sig)
                        if mm:
                            name = mm.group(2)
                        else:
                            # fallback: take first token before '('
                            name = sig.split('(')[0].strip().split()[-1]
                    if name:
                        doc_funcs.append(name)
                regex_funcs = extract_function_names(fp)
                all_funcs = sorted(set(doc_funcs + regex_funcs))
                out.append('\n| Module | Functions |')
                out.append('|---|---|')
                out.append('| {} | {} |'.format(mod, ', '.join(all_funcs)))

                # Now render function docblocks (use doc_funcs order first, then others)
                # Map names to comments
                name_to_comment = {}
                for (comment, sig) in items:
                    name = ''
                    if sig:
                        mm = re.match(r'([A-Za-z_][A-Za-z0-9_\*\s]+)\s+([A-Za-z_][A-Za-z0-9_]*)\s*\(', sig)
                        if mm:
                            name = mm.group(2)
                        else:
                            name = sig.split('(')[0].strip().split()[-1]
                    if name:
                        name_to_comment[name] = normalize_comment(comment)
                for fname in all_funcs:
                    out.append('\n#### ' + fname + '\n')
                    comment = name_to_comment.get(fname, '')
                    if comment:
                        out.append('\n' + '```text')
                        out.append(comment)
                        out.append('```')
                    else:
                        out.append('\n_No documentation available._')
    with open(TARGET_MD, 'w', encoding='utf-8') as f:
        f.write('\n'.join(out))
    print('Wrote', TARGET_MD)

if __name__ == '__main__':
    main()
